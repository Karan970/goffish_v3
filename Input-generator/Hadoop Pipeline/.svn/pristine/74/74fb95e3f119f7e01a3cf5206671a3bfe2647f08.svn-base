package in.dream_lab.hadoopPipeline.cc;

import in.dream_lab.hadoopPipeline.cc.GeneratePartitionSliceReducer.EdgeTuple;
import in.dream_lab.hadoopPipeline.cc.GeneratePartitionSliceReducer.RemoteVertexInfo;
import in.dream_lab.hadoopPipeline.cc.GeneratePartitionSliceReducer.SubgraphTuple;
import in.dream_lab.hadoopPipeline.cc.GeneratePartitionSliceReducer.VertexTuple;
import it.unimi.dsi.fastutil.longs.Long2ObjectMap;
import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap;

import java.io.IOException;
import java.io.Serializable;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;

import org.apache.hadoop.conf.Configuration;
import org.apache.hadoop.fs.FileSystem;
import org.apache.hadoop.fs.Path;
import org.apache.hadoop.io.IntWritable;
import org.apache.hadoop.io.Text;
import org.apache.hadoop.mapreduce.Reducer;


import edu.usc.goffish.gofs.IPartition;
import edu.usc.goffish.gofs.ISubgraph;
import edu.usc.goffish.gofs.Property;
import edu.usc.goffish.gofs.PropertySet;
import edu.usc.goffish.gofs.partition.Partition;
import edu.usc.goffish.gofs.partition.TemplateEdge;
import edu.usc.goffish.gofs.partition.TemplateGraph;
import edu.usc.goffish.gofs.partition.TemplateRemoteVertex;
import edu.usc.goffish.gofs.partition.TemplateSubgraph;
import edu.usc.goffish.gofs.partition.TemplateVertex;
import edu.usc.goffish.gofs.slice.HDFSStorageManager;
import edu.usc.goffish.gofs.slice.ISliceManager;
import edu.usc.goffish.gofs.slice.KryoSliceSerializer;
import edu.usc.goffish.gofs.slice.SliceManager;

public class VornoiSliceReducer extends Reducer<IntWritable,Text,Text,Text> {
	int partitionID;

	HashMap<Long, SubgraphTuple> Subgraphs = new HashMap<Long, SubgraphTuple>();

	@Override
	protected void reduce(IntWritable Key, Iterable<Text> values,Context context)
			throws IOException, InterruptedException {

		//TODO: Parse the input from Mapper in the form:
		//	KEY: IntWritable(srcPid)	VALUE: sb.append(srcid).append(",").append(srcSGid).append("#").append(inputLine[1]);
		//	inputLine[1] : <Eid,SinkID,SubgraphID,Pid:Eid,SinkID,SubgraphID,Pid:....> 
		//  Sink vertices are separated by ":"

		//System.out.println("TEST:  KEY: "+Key+ "  VALUE:"+values);
		partitionID=Key.get();
		//System.out.println("TESTKEY: " +partitionID);




		//Outer loop over each vertex in the partition
		for(Text v: values){
			//Extract the source ID and its subgraph ID
			String[] valueString = v.toString().split("#",-1);
			long sgid= Long.parseLong(valueString[0].split(",")[1]);
			long vid= Long.parseLong(valueString[0].split(",")[0]);
			//System.out.println("TEST: SGID:"+sgid + "  VID:"+vid);




			Long2ObjectMap<RemoteVertexInfo> RemoteVertexList = new Long2ObjectOpenHashMap<RemoteVertexInfo>();
			ArrayList<EdgeTuple> edgeList = new ArrayList<EdgeTuple>();

			//TODO: local and remote vertices are not separated by any separator but sinkVertices are separated by ":" 

			String[] sinkVertices=valueString[1].split(":");

			if(!Subgraphs.containsKey(sgid)){
				//inner loop over each adjacent vertex of src vertex
				for (int i1=0;i1<sinkVertices.length;i1++){

					//Each record is of the form <Eid,SinkID,SubgraphID,Pid>
					//from pid determine if it is local or remote
					String[] sinkTuple=sinkVertices[i1].split(",");

					int sinkPid=Integer.parseInt(sinkTuple[3]);
					long sinkID=Long.parseLong(sinkTuple[1]);
					long sinkSGID=Long.parseLong(sinkTuple[2]);
					long edgeID=Long.parseLong(sinkTuple[0]);


					if (sinkPid == partitionID){
						//local vertex
						//					protected EdgeTuple(long edgeId, long edgeSink) 
						EdgeTuple e=new EdgeTuple(edgeID,sinkID);
						edgeList.add(e);

					}
					else{	//remote vertex


						EdgeTuple e=new EdgeTuple(edgeID,sinkID);
						edgeList.add(e);
						//protected RemoteVertexInfo(int remotePartition, long remoteSubgraph) {
						RemoteVertexInfo r=new RemoteVertexInfo(sinkPid, sinkSGID);
						RemoteVertexList.put(sinkID, r);					
					}
				}
				edgeList.trimToSize();
				ArrayList<VertexTuple> AdjList = new ArrayList<VertexTuple>();
				VertexTuple V = new VertexTuple(vid, edgeList);
				AdjList.add(V);
				SubgraphTuple sg = new SubgraphTuple(sgid, AdjList, RemoteVertexList);
				Subgraphs.put(sgid, sg);

			}else{
				SubgraphTuple sg = Subgraphs.get(sgid);

				for (int i1=0;i1<sinkVertices.length;i1++){

					//Each record is of the form <Eid,SinkID,SubgraphID,Pid>
					//from pid determine if it is local or remote
					String[] sinkTuple=sinkVertices[i1].split(",");

					int sinkPid=Integer.parseInt(sinkTuple[3]);
					long sinkID=Long.parseLong(sinkTuple[1]);
					long sinkSGID=Long.parseLong(sinkTuple[2]);
					long edgeID=Long.parseLong(sinkTuple[0]);


					if (sinkPid == partitionID){
						//local vertex
						//					protected EdgeTuple(long edgeId, long edgeSink) 
						EdgeTuple e=new EdgeTuple(edgeID,sinkID);
						edgeList.add(e);

					}
					else{	//remote vertex


						EdgeTuple e=new EdgeTuple(edgeID,sinkID);
						edgeList.add(e);
						//protected RemoteVertexInfo(int remotePartition, long remoteSubgraph) {
						RemoteVertexInfo r=new RemoteVertexInfo(sinkPid, sinkSGID);
						sg.RemoteVertices.put(sinkID, r);
						//						RemoteVertexList.put(sinkID, r);					
					}
				}
				edgeList.trimToSize();
				VertexTuple V = new VertexTuple(vid, edgeList);
				sg.AdjacencyList.add(V);

			}

		}

			KryoSliceSerializer _serializer = new KryoSliceSerializer();

			Configuration conf1 = context.getConfiguration();
			String graphID1 = conf1.get("GraphID");

			Configuration conf= new Configuration();
			FileSystem dfs = FileSystem.get(conf);

			String dirName = graphID1+ "Partition"+partitionID;

			Path src = new Path(dfs.getWorkingDirectory()+"/"+dirName);

			//dfs.mkdirs(src); 

			HDFSStorageManager hdfsStorageManager= new HDFSStorageManager(src);
			ISliceManager sliceManager1 = SliceManager.create(_serializer, hdfsStorageManager );

			//long total;

			ArrayList<ISubgraph> subgraphs = new ArrayList<ISubgraph>(Subgraphs.keySet().size());
			for (SubgraphTuple subgraph : Subgraphs.values()) {
				//SubgraphTuple subgraph = S

				// recreate template
				TemplateGraph template = new TemplateGraph(true, subgraph.AdjacencyList.size());
				for (int j = 0; j < subgraph.AdjacencyList.size(); j++) {
					VertexTuple vertex = subgraph.AdjacencyList.get(j);
					//                System.out.println("IN loop vid"+vertex.VertexId);
					// retrieve source
					TemplateVertex source = template.getVertex(vertex.VertexId);
					if (source == null) {
						RemoteVertexInfo rvi = subgraph.RemoteVertices.get(vertex.VertexId);
						if (rvi != null) {
							//                      System.out.println("Remote vertex "+vertex.VertexId);
							source = new TemplateRemoteVertex(vertex.VertexId, rvi.RemotePartition, rvi.RemoteSubgraph);
						} else {
							source = new TemplateVertex(vertex.VertexId);
						}
						template.addVertex(source);
					}

					for (int k = 0; k < vertex.Edges.size(); k++) {
						EdgeTuple edge = vertex.Edges.get(k);

						// retrieve sink
						TemplateVertex sink = template.getVertex(edge.EdgeSink);
						if (sink == null) {
							RemoteVertexInfo rvi = subgraph.RemoteVertices.get(edge.EdgeSink);
							if (rvi != null) {
								sink = new TemplateRemoteVertex(edge.EdgeSink, rvi.RemotePartition, rvi.RemoteSubgraph);
							} else {
								sink = new TemplateVertex(edge.EdgeSink);
							}
							template.addVertex(sink);
						}

						template.connectEdge(new TemplateEdge(edge.EdgeId, source, sink));
					}
				}
				PropertySet EmptyPropertySet = new PropertySet(Collections.<Property>emptyList());
				subgraphs.add(new TemplateSubgraph(subgraph.SubgraphId, template, EmptyPropertySet, EmptyPropertySet));
				//System.out.println(template.toString()+ " "+ template.edges()+"  "+template.numVertices()+" "+template.numEdges()+ " "+template.vertices());

			}
			PropertySet EmptyPropertySet = new PropertySet(Collections.<Property>emptyList());
			IPartition partition=new Partition(partitionID, true, subgraphs,EmptyPropertySet , EmptyPropertySet);

			//TODO:add a new method in sliceManager to write the template to HDFS
			sliceManager1.writePartitionTemplate(partition);
			//   System.out.println("total  "+total );


		


	}
}